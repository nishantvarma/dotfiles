#!/usr/bin/env python

import os
import shutil
import subprocess
import sys
from contextlib import contextmanager
from pathlib import Path

from blessed import Terminal

EDIT = "e"
FZYEDIT = "fze"
FZYOPEN = "fzo"
FZYSEARCH = "fzs"
OPEN = "o"
SHELL = ["rc"]
TAGS = ".config/fm/tagged"
TERM = "st"
VC = "v"


class FM:
    # core

    def __init__(self, path="."):
        self.t = Terminal()
        self.cwd = Path(path).absolute()
        self.last = None
        self.files, self.clip, self.sel = [], [], set()
        self.cutting, self.hidden, self.idx = False, False, 0
        self.alt = None
        self.pat = str()
        self.tags = Path.home() / TAGS
        self.tags.mkdir(parents=True, exist_ok=True)

    def run(self):
        os.chdir(self.cwd)
        self.title(f"fm:{self.cwd.resolve()}")
        t = self.t
        self.keys = {
            "a": ("Add file", lambda: self.create("touch", Path.touch)),
            "A": ("Add dir", lambda: self.create("mkdir", Path.mkdir)),
            "c": ("Copy", self.copy),
            "d": ("Delete", self.rm),
            "e": ("Edit", self.edit),
            "E": ("Fuzzy edit", lambda: self.spawn(FZYEDIT)),
            "f": ("Check", lambda: self.spawn("lint", cur=True, wait=True)),
            "F": ("Format", lambda: self.spawn("lint", "-f", cur=True, wait=True)),
            "g": ("Goto", self.goto),
            "h": ("Help", self.help),
            "j": (None, lambda: self.mv(1)),
            "k": (None, lambda: self.mv(-1)),
            "l": ("Link", self.link),
            "n": ("Next", self.next),
            "N": ("Prev", self.prev),
            "o": ("Open", lambda: self.enter),
            "O": ("Fuzzy open", lambda: self.spawn(FZYOPEN)),
            "p": ("Paste", self.paste),
            "q": ("Quit", self.quit),
            "r": ("Rename", self.rename),
            "s": ("Shell", self.sh),
            "t": ("Tag", self.tag),
            "u": ("Unclip", lambda: setattr(self, "clip", [])),
            "v": ("VC", self.vc),
            "V": ("Git gui", lambda: self.spawn("gitk")),
            "x": ("Cut", self.cut),
            "z": ("Outline", lambda: self.spawn("outline", cur=True)),
            "S": ("Search", self.fzsearch),
            " ": ("Select", self.select),
            "*": ("Chmod +x", self.chmod),
            ".": ("Hidden", lambda: setattr(self, "hidden", not self.hidden)),
            "/": ("Search", self.search),
            "'": ("Alt", lambda: setattr(self, "alt", None if self.alt else self.cwd)),
            "`": ("Tagged", lambda: self.cd(self.tags)),
            "~": ("Home", lambda: self.cd(Path.home())),
            "\n": (None, self.enter),
            "KEY_DOWN": (None, lambda: self.mv(1)),
            "KEY_ENTER": (None, self.enter),
            "KEY_LEFT": (None, lambda: self.cd(self.cwd.parent)),
            "KEY_RIGHT": (None, self.enter),
            "KEY_TAB": (None, self.tab),
            "KEY_UP": (None, lambda: self.mv(-1)),
        }
        try:
            with t.fullscreen(), t.cbreak(), t.hidden_cursor():
                while True:
                    self.ls()
                    self.draw()
                    key = t.inkey(timeout=1)
                    if not key:
                        continue
                    k = key.name or str(key)
                    if k in self.keys:
                        if self.keys[k][1]():
                            break
                    elif key.isdigit():
                        self.jump(key)
        except KeyboardInterrupt:
            self.quit()

    def draw(self):
        t = self.t
        self.out(t.home)
        title = self.bold(self.tilde(self.cwd.resolve()))
        if self.sel:
            title += self.dim(f" [{len(self.sel)}]")
        if self.clip:
            mode = "cut" if self.cutting else "cp"
            title += self.dim(f" {mode}:{len(self.clip)}")
        if self.alt:
            title += self.dim(f" alt:{self.alt.name}")
        print(title + t.clear_eol)
        h = t.height - 2
        if len(self.files) > h:
            h -= 1
        off = self.scroll(h)
        visible = self.files[off : off + h]
        for i, f in enumerate(visible, off):
            print(self.row(i, f) + t.clear_eol)
        extra = h - len(visible)
        if len(self.files) > h:
            hidden = len(self.files) - h
            print(self.dim(f" +{hidden}") + t.clear_eol)
            extra -= 1
        for _ in range(extra):
            print(t.clear_eol)
        self.status()

    # actions

    def cd(self, p):
        self.last = self.cwd
        self.cwd, self.idx = p.absolute(), 0
        try:
            os.chdir(self.cwd)
        except PermissionError:
            self.cwd = self.last
            self.status("permission denied")
            self.t.inkey(timeout=2)
            return
        self.title(f"fm:{self.cwd.resolve()}")
        self.sel.clear()

    def chmod(self):
        if self.cur:
            mode = self.cur.stat().st_mode
            if mode & 0o111:
                self.cur.chmod(mode & ~0o111)
            else:
                self.cur.chmod(mode | 0o111)

    def copy(self):
        self.yank(False)

    def create(self, label, fn):
        name = self.prompt(f"{label}: ")
        if name:
            self.catch(fn, self.cwd / name)

    def cut(self):
        self.yank(True)

    def edit(self):
        if self.cur and self.cur.is_file():
            self.spawn(EDIT, cur=True)

    def enter(self):
        if not self.cur:
            return
        if self.cur.is_dir():
            self.cd(self.cur)
        else:
            self.spawn(OPEN, cur=True)

    def goto(self):
        s = self.prompt("goto: ", self.compl)
        if not s:
            return
        p = Path(s).expanduser().resolve()
        if p.is_dir():
            self.cd(p)
        elif p.is_file():
            self.spawn(OPEN, p)

    def help(self):
        self.out(self.t.home + self.t.clear)
        print(self.bold("Shortcuts") + "\n")
        for k, (desc, _) in self.keys.items():
            if desc:
                print(f"  {self.yellow(f'{k:8}')} {desc}")
        print(self.dim("\n  Press any key"))
        self.t.inkey()

    def jump(self, first):
        t = self.t
        self.status(first, cursor=True)
        buf = first
        while True:
            key = t.inkey(timeout=1)
            if not key:
                break
            if self.isesc(key):
                self.out(t.civis)
                return
            if self.isenter(key):
                break
            if key.isdigit():
                buf += key
                self.out(key)
            else:
                break
        self.out(t.civis)
        if buf.isdigit():
            n = int(buf) - 1
            if 0 <= n < len(self.files):
                self.idx = n

    def link(self):
        if not self.clip:
            return
        for src in self.clip:
            dst = self.cwd / src.name
            if not dst.exists():
                rel = os.path.relpath(src, self.cwd)
                dst.symlink_to(rel)
        self.clip = []

    def ls(self):
        try:
            self.files = sorted(
                [
                    f
                    for f in self.cwd.iterdir()
                    if self.hidden or not f.name.startswith(".")
                ],
                key=lambda p: (not (p.is_symlink() or p.is_dir()), p.name.lower()),
            )
        except PermissionError:
            self.files = []
        self.idx = max(0, min(len(self.files) - 1, self.idx))

    def mv(self, d):
        if self.files:
            self.idx = max(0, min(len(self.files) - 1, self.idx + d))

    def next(self):
        self.find(1)

    def paste(self):
        for src in self.clip:
            dst = self.cwd / src.name
            if dst.exists():
                name = self.prompt(f"name [{src.name}]: ")
                if name is None:
                    continue
                dst = self.cwd / (name or src.name)
            try:
                if self.cutting:
                    shutil.move(src, dst)
                elif src.is_dir():
                    shutil.copytree(src, dst)
                else:
                    shutil.copy2(src, dst)
            except (OSError, shutil.Error):
                pass
        if self.cutting:
            self.clip = []

    def prev(self):
        self.find(-1)

    def quit(self):
        return True

    def rename(self):
        if not self.cur:
            return
        name = self.prompt("mv: ", default=self.cur.name)
        if name:
            self.catch(self.cur.rename, self.cwd / name)

    def rm(self):
        paths = self.targets()
        if not paths:
            return
        names = " ".join(p.name for p in paths)
        self.status(f"rm {names}? ", cursor=True)
        if self.t.inkey() != "y":
            return
        for p in paths:
            try:
                if p.is_dir():
                    shutil.rmtree(p)
                else:
                    p.unlink()
            except OSError:
                pass
        self.sel.clear()

    def search(self):
        pat = self.prompt("/")
        if not pat:
            return
        self.pat = pat.lower()
        self.next()

    def fzsearch(self):
        if pat := self.prompt("rg: "):
            self.spawn(FZYSEARCH, pat)

    def select(self):
        if self.cur:
            self.sel ^= {self.cur}

    def sh(self):
        shfile = self.ctx / "sh"
        if shfile.is_file() and os.access(shfile, os.X_OK):
            cmd = "./sh; true"
        else:
            cmd = " ".join(SHELL) + "; true"
        subprocess.Popen(
            [TERM, "-e", "sh", "-c", cmd],
            cwd=self.ctx,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    def tab(self):
        if self.alt:
            prev = self.cwd
            self.cd(self.alt)
            self.alt = prev
        elif self.last:
            self.cd(self.last)

    def tag(self):
        default = self.cwd.name
        name = self.prompt(f"tag [{default}]: ")
        if name is None:
            return
        name = name or default
        (self.tags / name).unlink(missing_ok=True)
        rel = os.path.relpath(self.cwd, self.tags)
        (self.tags / name).symlink_to(rel)

    def vc(self):
        self.spawn(VC)

    # helpers

    def catch(self, fn, *args, timeout=2):
        try:
            fn(*args)
        except OSError as e:
            self.status(f"error: {e.strerror}")
            self.t.inkey(timeout=timeout)

    def compl(self, s):
        p = Path(s).expanduser()
        d, pre = (p, "") if p.is_dir() else (p.parent, p.name)
        try:
            m = [f for f in d.iterdir() if f.name.startswith(pre)]
        except OSError:
            return s
        if not m:
            return s
        if len(m) == 1:
            return str(m[0]) + "/" if m[0].is_dir() else str(m[0])
        return str(d / os.path.commonprefix([f.name for f in m]))

    @property
    def ctx(self):
        if self.cwd.name == "tagged" and self.cur and self.cur.is_dir():
            return self.cur
        return self.cwd

    @property
    def cur(self):
        return self.files[self.idx] if self.files else None

    def find(self, d):
        if not self.pat or not self.files:
            return
        for i in range(1, len(self.files) + 1):
            idx = (self.idx + d * i) % len(self.files)
            if self.pat in self.files[idx].name.lower():
                self.idx = idx
                return

    def hl(self, idx, f):
        if idx == self.idx:
            return self.t.on_gray20
        if f in self.sel:
            return self.t.on_gray30
        return str()

    def isbs(self, key):
        return key.name == "KEY_BACKSPACE" or key == chr(127)

    def isenter(self, key):
        return key.name == "KEY_ENTER" or key == "\n"

    def isesc(self, key):
        return key.name == "KEY_ESCAPE"

    def prompt(self, msg, complete=None, default=str()):
        t = self.t
        buf, pos = default, len(default)

        def draw():
            self.status(msg + buf, cursor=True)
            self.out(t.move_left * (len(buf) - pos))

        draw()
        while True:
            key = t.inkey()
            if self.isesc(key) or key.name == "KEY_DOWN":
                self.out(t.civis)
                return None
            if self.isenter(key):
                self.out(t.civis)
                return buf
            if key.name == "KEY_LEFT" and pos > 0:
                pos -= 1
            elif key.name == "KEY_RIGHT" and pos < len(buf):
                pos += 1
            elif self.isbs(key) and pos > 0:
                buf = buf[: pos - 1] + buf[pos:]
                pos -= 1
            elif key.name == "KEY_TAB" and complete:
                buf = complete(buf)
                pos = len(buf)
            elif key.isprintable():
                buf = buf[:pos] + key + buf[pos:]
                pos += 1
            else:
                continue
            draw()

    def row(self, i, f):
        fmt, suf = self.style(f)
        bg = self.hl(i, f)
        num = self.yellow(f"{i + 1:2}")
        name = fmt(f.name + suf)
        return f" {num}  {bg}{name}"

    def scroll(self, h):
        if len(self.files) <= h:
            return 0
        return max(0, min(self.idx - h // 2, len(self.files) - h))

    def spawn(self, *cmd, cur=False, wait=False):
        with self.tty():
            if cur:
                cmd = cmd + (self.cur,)
            cmd = tuple(str(c) for c in cmd if c is not None)
            try:
                ret = subprocess.run(cmd, cwd=self.ctx)
                if wait or ret.returncode:
                    os.system("pause")
            except KeyboardInterrupt:
                pass

    def style(self, p):
        if p.is_symlink():
            return self.cyan, "@"
        if p.is_dir():
            return self.blue, "/"
        if os.access(p, os.X_OK):
            return self.green, "*"
        return self.plain, str()

    def targets(self):
        if self.sel:
            return list(self.sel)
        if self.cur:
            return [self.cur]
        return []

    def tilde(self, p):
        try:
            return "~/" + str(p.relative_to(Path.home()))
        except ValueError:
            return str(p)

    @contextmanager
    def tty(self):
        t = self.t
        self.out(t.exit_fullscreen + t.clear + t.normal_cursor)
        os.system("stty sane")
        try:
            yield
        finally:
            os.system("stty -echo -icanon")
            self.out(t.enter_fullscreen + t.clear + t.civis)

    def yank(self, cut):
        self.clip = self.targets()
        self.cutting = cut
        self.sel.clear()

    # output

    def bold(self, s):
        return self.t.bold + s + self.t.normal

    def blue(self, s):
        return self.t.blue + s + self.t.normal

    def cyan(self, s):
        return self.t.cyan + s + self.t.normal

    def dim(self, s):
        return self.t.dim + s + self.t.normal

    def green(self, s):
        return self.t.green + s + self.t.normal

    def out(self, *args):
        print(*args, end=str(), flush=True)

    def plain(self, s):
        return s + self.t.normal

    def status(self, msg=str(), cursor=False):
        pos = self.t.move_xy(0, self.t.height - 1)
        cur = self.t.cnorm if cursor else self.t.civis
        self.out(pos + self.t.clear_eol + cur + msg)

    def title(self, s):
        self.out(f"{chr(27)}]2;{s}{chr(7)}")

    def yellow(self, s):
        return self.t.yellow + s + self.t.normal


if __name__ == "__main__":
    FM(sys.argv[1] if sys.argv[1:] else ".").run()
